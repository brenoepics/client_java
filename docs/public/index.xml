<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>client_java</title>
    <link>http://localhost:1313/</link>
    <description>Recent content on client_java</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="http://localhost:1313/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Config</title>
      <link>http://localhost:1313/config/config/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/config/config/</guid>
      <description>Location of the Properties File Metrics Properties Exemplar Properties Exporter Properties Exporter Filter Properties Exporter HTTPServer Properties Exporter OpenTelemetry Properties The Prometheus metrics library provides multiple options how to override configuration at runtime:&#xA;Properties file System properties Future releases will add more options, like configuration via environment variables.&#xA;Example:&#xA;io.prometheus.exporter.httpServer.port = 9401 The property above changes the port for the HTTPServer exporter to 9401.&#xA;Properties file: Add the line above to the properties file.</description>
    </item>
    <item>
      <title>Formats</title>
      <link>http://localhost:1313/exporters/formats/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/exporters/formats/</guid>
      <description>All exporters the following exposition formats:&#xA;OpenMetrics text format Prometheus text format Prometheus protobuf format Moreover, gzip encoding is supported for each of these formats.&#xA;Scraping with a Prometheus server The Prometheus server sends an Accept header to specify which format is requested. By default, the Prometheus server will scrape OpenMetrics text format with gzip encoding. If the Prometheus server is started with --enable-feature=native-histograms, it will scrape Prometheus protobuf format instead.</description>
    </item>
    <item>
      <title>JVM</title>
      <link>http://localhost:1313/instrumentation/jvm/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/instrumentation/jvm/</guid>
      <description>The JVM instrumentation module provides a variety of out-of-the-box JVM and process metrics. To use it, add the following dependency:&#xA;Gradle implementation &amp;#39;io.prometheus:prometheus-metrics-instrumentation-jvm:1.0.0&amp;#39; Maven &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;io.prometheus&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;prometheus-metrics-instrumentation-jvm&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.0.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; Now, you can register the JVM metrics as follows:&#xA;JvmMetrics.builder().register(); The line above will initialize all JVM metrics and register them with the default registry. If you want to register the metrics with a custom PrometheusRegistry, you can pass the registry as parameter to the register() call.</description>
    </item>
    <item>
      <title>Model</title>
      <link>http://localhost:1313/internals/model/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/internals/model/</guid>
      <description>The illustration below shows the internal architecture of the Prometheus Java client library.&#xA;prometheus-metrics-core This is the user facing metrics library, implementing the core metric types, like Counter, Gauge Histogram, and so on.&#xA;All metric types implement the Collector interface, i.e. they provide a collect() method to produce snapshots.&#xA;prometheus-metrics-model The model is an internal library, implementing read-only immutable snapshots. These snapshots are returned by the Collector.collect() method.&#xA;There is no need for users to use prometheus-metrics-model directly.</description>
    </item>
    <item>
      <title>OTLP</title>
      <link>http://localhost:1313/otel/otlp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/otel/otlp/</guid>
      <description>The Prometheus Java client library allows you to push metrics to an OpenTelemetry endpoint using the OTLP protocol.&#xA;To implement this, you need to include prometheus-metrics-exporter as a dependency&#xA;Gradle implementation &amp;#39;io.prometheus:prometheus-metrics-exporter-opentelemetry:1.0.0&amp;#39; Maven &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;io.prometheus&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;prometheus-metrics-exporter-opentelemetry&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.0.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; Initialize the OpenTelemetryExporter in your Java code:&#xA;OpenTelemetryExporter.builder() // optional: call configuration methods here .buildAndStart(); By default, the OpenTelemetryExporter will push metrics every 60 seconds to localhost:4317 using grpc protocol. You can configure this in code using the OpenTelemetryExporter.</description>
    </item>
    <item>
      <title>Quickstart</title>
      <link>http://localhost:1313/getting-started/quickstart/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/getting-started/quickstart/</guid>
      <description>This tutorial shows the quickest way to get started with the Prometheus Java metrics library.&#xA;Dependencies We use the following dependencies:&#xA;prometheus-metrics-core is the actual metrics library. prometheus-metrics-instrumentation-jvm provides out-of-the-box JVM metrics. prometheus-metrics-exporter-httpserver is a standalone HTTP server for exposing Prometheus metrics. Gradle implementation &amp;#39;io.prometheus:prometheus-metrics-core:1.0.0&amp;#39;&#xD;implementation &amp;#39;io.prometheus:prometheus-metrics-instrumentation-jvm:1.0.0&amp;#39;&#xD;implementation &amp;#39;io.prometheus:prometheus-metrics-exporter-httpserver:1.0.0&amp;#39; Maven &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;io.prometheus&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;prometheus-metrics-core&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.0.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;io.prometheus&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;prometheus-metrics-instrumentation-jvm&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.0.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;io.prometheus&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;prometheus-metrics-exporter-httpserver&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.0.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; There are alternative exporters as well, for example if you are using a Servlet container like Tomcat or Undertow you might want to use prometheus-exporter-servlet-jakarta rather than a standalone HTTP server.</description>
    </item>
    <item>
      <title>Simpleclient</title>
      <link>http://localhost:1313/migration/simpleclient/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/migration/simpleclient/</guid>
      <description>The Prometheus Java client library 1.0.0 is a complete rewrite of the underlying data model, and is not backwards compatible with releases 0.16.0 and older for a variety of reasons:&#xA;The old data model was based on OpenMetrics. Native histograms don&amp;rsquo;t fit with the OpenMetrics model because they don&amp;rsquo;t follow the &amp;ldquo;every sample has exactly one double value&amp;rdquo; paradigm. It was a lot cleaner to implement a dedicated prometheus-metrics-model than trying to fit native histograms into the existing OpenMetrics-based model.</description>
    </item>
    <item>
      <title>Filter</title>
      <link>http://localhost:1313/exporters/filter/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/exporters/filter/</guid>
      <description>All exporters support a name[] URL parameter for querying only specific metric names. Examples:&#xA;/metrics?name[]=jvm_threads_current will query the metric named jvm_threads_current. /metrics?name[]=jvm_threads_current&amp;amp;name[]=jvm_threads_daemon will query two metrics, jvm_threads_current and jvm_threads_daemon. Add the following to the scape job configuration in prometheus.yml to make the Prometheus server send the name[] parameter:&#xA;params: name[]: - jvm_threads_current - jvm_threads_daemon </description>
    </item>
    <item>
      <title>Registry</title>
      <link>http://localhost:1313/getting-started/registry/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/getting-started/registry/</guid>
      <description>In order to expose metrics, you need to register them with a PrometheusRegistry. We are using a counter as an example here, but the register() method is the same for all metric types.&#xA;Registering a Metrics with the Default Registry Counter eventsTotal = Counter.builder() .name(&amp;#34;events_total&amp;#34;) .help(&amp;#34;Total number of events&amp;#34;) .register(); // &amp;lt;-- implicitly uses PrometheusRegistry.defaultRegistry The register() call above builds the counter and registers it with the global static PrometheusRegistry.defaultRegistry. Using the default registry is recommended.</description>
    </item>
    <item>
      <title>Tracing</title>
      <link>http://localhost:1313/otel/tracing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/otel/tracing/</guid>
      <description>OpenTelemetryâ€™s vision statement says that telemetry should be loosely coupled, allowing end users to pick and choose from the pieces they want without having to bring in the rest of the project, too. In that spirit, you might choose to instrument your Java application with the Prometheus Java client library for metrics, and attach the OpenTelemetry Java agent to get distributed tracing.&#xA;First, if you attach the OpenTelemetry Java agent you might want to turn off OTel&amp;rsquo;s built-in metrics, because otherwise you get metrics from both the Prometheus Java client library and the OpenTelemetry agent (technically it&amp;rsquo;s no problem to get both metrics, it&amp;rsquo;s just not a common use case).</description>
    </item>
    <item>
      <title>HTTPServer</title>
      <link>http://localhost:1313/exporters/httpserver/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/exporters/httpserver/</guid>
      <description>The HTTPServer is a standalone server for exposing a metric endpoint. A minimal example application for HTTPServer can be found in the examples directory.&#xA;HTTPServer server = HTTPServer.builder() .port(9400) .buildAndStart(); By default, HTTPServer binds to any IP address, you can change this with hostname() or inetAddress().&#xA;HTTPServer is configured with three endpoints:&#xA;/metrics for Prometheus scraping. /-/healthy for simple health checks. / the default handler is a static HTML page. The default handler can be changed with defaultHandler().</description>
    </item>
    <item>
      <title>Labels</title>
      <link>http://localhost:1313/getting-started/labels/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/getting-started/labels/</guid>
      <description>The following shows an example of a Prometheus metric in text format:&#xA;# HELP payments_total total number of payments&#xD;# TYPE payments_total counter&#xD;payments_total{status=&amp;#34;error&amp;#34;,type=&amp;#34;paypal&amp;#34;} 1.0&#xD;payments_total{status=&amp;#34;success&amp;#34;,type=&amp;#34;credit card&amp;#34;} 3.0&#xD;payments_total{status=&amp;#34;success&amp;#34;,type=&amp;#34;paypal&amp;#34;} 2.0 The example shows a counter metric named payments_total with two labels: status and type. Each individual data point (each line in text format) is identified by the unique combination of its metric name and its label name/value pairs.&#xA;Creating a Metric with Labels Labels are supported for all metric types.</description>
    </item>
    <item>
      <title>Names</title>
      <link>http://localhost:1313/otel/names/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/otel/names/</guid>
      <description>OpenTelemetry naming conventions are different from Prometheus naming conventions. The mapping from OpenTelemetry metric names to Prometheus metric names is well defined in OpenTelemetry&amp;rsquo;s Prometheus and OpenMetrics Compatibility spec, and the OpenTelemetryExporter implements that specification.&#xA;The goal is, if you set up a pipeline as illustrated below, you will see the same metric names in the Prometheus server as if you had exposed Prometheus metrics directly.&#xA;The main steps when converting OpenTelemetry metric names to Prometheus metric names are:</description>
    </item>
    <item>
      <title>Metric Types</title>
      <link>http://localhost:1313/getting-started/metric-types/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/getting-started/metric-types/</guid>
      <description>The Prometheus Java metrics library implements the metric types defined in the OpenMetrics standard:&#xA;Counter Gauge Histogram Summary Info StateSet GaugeHistogram and Unknown Counter Counter is the most common and useful metric type. Counters can only increase, but never decrease. In the Prometheus query language, the rate() function is often used for counters to calculate the average increase per second.&#xA;Counter values do not need to be integers. In many cases counters represent a number of events (like the number of requests), and in that case the counter value is an integer.</description>
    </item>
    <item>
      <title>Servlet</title>
      <link>http://localhost:1313/exporters/servlet/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/exporters/servlet/</guid>
      <description>The PrometheusMetricsServlet is a Jakarta Servlet for exposing a metric endpoint.&#xA;web.xml The old-school way of configuring a servlet is in a web.xml file:&#xA;&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;web-app xmlns=&amp;#34;https://jakarta.ee/xml/ns/jakartaee&amp;#34; xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xsi:schemaLocation=&amp;#34;https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd&amp;#34; version=&amp;#34;5.0&amp;#34;&amp;gt; &amp;lt;servlet&amp;gt; &amp;lt;servlet-name&amp;gt;prometheus-metrics&amp;lt;/servlet-name&amp;gt; &amp;lt;servlet-class&amp;gt;io.prometheus.metrics.exporter.servlet.jakarta.PrometheusMetricsServlet&amp;lt;/servlet-class&amp;gt; &amp;lt;/servlet&amp;gt; &amp;lt;servlet-mapping&amp;gt; &amp;lt;servlet-name&amp;gt;prometheus-metrics&amp;lt;/servlet-name&amp;gt; &amp;lt;url-pattern&amp;gt;/metrics&amp;lt;/url-pattern&amp;gt; &amp;lt;/servlet-mapping&amp;gt; &amp;lt;/web-app&amp;gt; Programmatic Today, most Servlet applications use an embedded Servlet container and configure Servlets programmatically rather than via web.xml. The API for that depends on the Servlet container. The examples directory has an example of an embedded Tomcat container with the PrometheusMetricsServlet configured.</description>
    </item>
    <item>
      <title>Callbacks</title>
      <link>http://localhost:1313/getting-started/callbacks/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/getting-started/callbacks/</guid>
      <description>The section on metric types showed how to use metrics that actively maintain their state.&#xA;This section shows how to create callback-based metrics, i.e. metrics that invoke a callback at scrape time to get the current values.&#xA;For example, let&amp;rsquo;s assume we have two instances of a Cache, a coldCache and a hotCache. The following implements a callback-based cache_size_bytes metric:&#xA;Cache coldCache = new Cache(); Cache hotCache = new Cache(); GaugeWithCallback.</description>
    </item>
    <item>
      <title>Spring</title>
      <link>http://localhost:1313/exporters/spring/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/exporters/spring/</guid>
      <description>Alternative: Use Spring&amp;rsquo;s Built-in Metrics Library Spring Boot has a built-in metric library named Micrometer, which supports Prometheus exposition format and can be set up in three simple steps:&#xA;Add the org.springframework.boot:spring-boot-starter-actuator dependency. Add the io.micrometer:micrometer-registry-prometheus as a runtime dependency. Enable the Prometheus endpoint by adding the line management.endpoints.web.exposure.include=prometheus to application.properties. Note that Spring&amp;rsquo;s default Prometheus endpoint is /actuator/prometheus, not /metrics.&#xA;In most cases the built-in Spring metrics library will work for you and you don&amp;rsquo;t need the Prometheus Java library in Spring applications.</description>
    </item>
    <item>
      <title>Performance</title>
      <link>http://localhost:1313/getting-started/performance/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/getting-started/performance/</guid>
      <description>This section has tips on how to use the Prometheus Java client in high performance applications.&#xA;Specify Label Values Only Once For high performance applications, we recommend to specify label values only once, and then use the data point directly.&#xA;This applies to all metric types. Let&amp;rsquo;s use a counter as an example here:&#xA;Counter requestCount = Counter.builder() .name(&amp;#34;requests_total&amp;#34;) .help(&amp;#34;total number of requests&amp;#34;) .labelNames(&amp;#34;path&amp;#34;, &amp;#34;status&amp;#34;) .register(); You could increment the counter above like this:</description>
    </item>
    <item>
      <title>Multi-Target Pattern</title>
      <link>http://localhost:1313/getting-started/multi-target/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/getting-started/multi-target/</guid>
      <description>This is for the upcoming release 1.1.0. To support multi-target pattern you can create a custom collector overriding the purposed internal method in ExtendedMultiCollector see SampleExtendedMultiCollector in io.prometheus.metrics.examples.httpserver&#xA;public class SampleExtendedMultiCollector extends ExtendedMultiCollector { public SampleExtendedMultiCollector() { super(); } @Override protected MetricSnapshots collectMetricSnapshots(PrometheusScrapeRequest scrapeRequest) { GaugeSnapshot.Builder gaugeBuilder = GaugeSnapshot.builder(); gaugeBuilder.name(&amp;#34;x_load&amp;#34;).help(&amp;#34;process load&amp;#34;); CounterSnapshot.Builder counterBuilder = CounterSnapshot.builder(); counterBuilder.name(PrometheusNaming.sanitizeMetricName(&amp;#34;x_calls_total&amp;#34;)).help(&amp;#34;invocations&amp;#34;); String[] targetNames = scrapeRequest.getParameterValues(&amp;#34;target&amp;#34;); String targetName; String[] procs = scrapeRequest.getParameterValues(&amp;#34;proc&amp;#34;); if (targetNames == null || targetNames.</description>
    </item>
  </channel>
</rss>
